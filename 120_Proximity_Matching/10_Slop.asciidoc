=== 混合起来

需要准确的短语去匹配((("proximity matching", "slop parameter")))可能是过于严格的约束。我们也许只需要对包含 ``quick brown fox'' 的文档，进行 ``quick fox,'' 的匹配，即使在位置上不是严格的相等。 

因此我们通过 `slop` 参数，引入一种较为灵活的短语匹配：

[source,js]
--------------------------------------------------
GET /my_index/my_type/_search
{
    "query": {
        "match_phrase": {
            "title": {
            	"query": "quick fox",
            	"slop":  1
            }
        }
    }
}
--------------------------------------------------
// SENSE: 120_Proximity_Matching/10_Slop.json

这个 `slop`  参数告诉 `match_phrase` 查询，文档被认定为一次匹配时，允许项之间可以有多远的距离((("match_phrase query", "slop parameter")))。多远距离，意味着，你需要移动一个项多少次才能达到此次查询与文档的匹配？ 

我们以一个简单例子开头。为了令包含 `quick brown fox` 的文档被 `quick fox` 查询匹配，我们需要将 `slop` 设置为 `1`:  


                Pos 1         Pos 2         Pos 3
    -----------------------------------------------
    Doc:        quick         brown         fox
    -----------------------------------------------
    Query:      quick         fox
    Slop 1:     quick                 ↳     fox

即使我们使用了 `slop` 参数,分词间可以不再为了匹配而要保持同样的序列。但所有的分词仍然需要在短语匹配中出现。当 `slop` 值足够高时，分词即可以任何顺序排列。	

为了令 `fox quick` 的查询匹配我们文档，我们需要将 `slop` 设置为 `3`:

                Pos 1         Pos 2         Pos 3
    -----------------------------------------------
    Doc:        quick         brown         fox
    -----------------------------------------------
    Query:      fox           quick
    Slop 1:     fox|quick  ↵  <1>
    Slop 2:     quick      ↳  fox
    Slop 3:     quick                 ↳     fox

<1> 注意在这一步中 `fox` 和 `quick` 占据了同样的位置，因此将 `fox quick` 的顺序转换为 `quick fox` 需要两步，或者将 `slop` 设置为 `2`。  

